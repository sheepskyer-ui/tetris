<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover"/>
<title>漂亮的俄罗斯方块（Tetris）</title>
<style>
  :root{
    --cell-size: calc(min(40vw, 480px) / 10); /* responsive */
    --cols: 10;
    --rows: 20;
    --side-w: 240px;
    --bg-top: #071029;
    --bg-bottom: #3b0f46;
    --panel-bg: rgba(0,0,0,0.35);
    --font: "Helvetica Neue", Arial, sans-serif;
  }
  html,body{
    height:100%;
    margin:0;
    font-family: var(--font);
    -webkit-user-select:none;
    -ms-user-select:none;
    user-select:none;
    background: linear-gradient(180deg,var(--bg-top),var(--bg-bottom));
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
    box-sizing:border-box;
  }
  #container{
    display:flex;
    gap:18px;
    align-items:flex-start;
    filter: drop-shadow(0 10px 30px rgba(0,0,0,0.6));
    max-width: calc(100% - 32px);
  }
  /* board area */
  #boardWrap{
    position:relative;
    width: calc(var(--cell-size) * var(--cols));
    height: calc(var(--cell-size) * var(--rows));
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border-radius:12px;
    overflow:hidden;
    border: 1px solid rgba(255,255,255,0.03);
  }
  canvas { display:block; width:100%; height:100%; }
  /* side panel */
  #panel{
    width:var(--side-w);
    color:#fff;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .panel-card{
    background: var(--panel-bg);
    padding:12px;
    border-radius:10px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.03);
  }
  h1{ margin:0; font-size:18px; letter-spacing:0.6px;}
  .small { font-size:12px; color:rgba(255,255,255,0.85); margin-top:6px;}
  .preview, .hold {
    width:100%;
    height:110px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .stat{
    display:flex; justify-content:space-between; align-items:center;
  }
  .controls{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    justify-content:center;
  }
  .btn{
    background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(0,0,0,0.12));
    border-radius:8px;
    padding:10px 14px;
    color:#fff;
    min-width:48px;
    text-align:center;
    font-weight:600;
    box-shadow:0 4px 8px rgba(0,0,0,0.35);
    touch-action: manipulation;
    user-select:none;
  }
  .big{
    font-size:18px;
    padding:12px 18px;
  }
  .hint{ font-size:12px; color:rgba(255,255,255,0.7); }
  #overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }
  #overlay .box{
    pointer-events:auto;
    background:rgba(0,0,0,0.6);
    color:#fff;
    padding:18px;
    border-radius:12px;
    text-align:center;
    max-width:80%;
  }
  /* responsive for small screens */
  @media (max-width:700px){
    #container{ flex-direction:column; align-items:center; gap:12px; }
    #panel{ width:100%; max-width:480px; }
    :root{ --side-w: calc(100% - calc(var(--cell-size)*var(--cols)) - 36px); }
  }
</style>
</head>
<body>
<div id="container">
  <div id="boardWrap">
    <canvas id="board" width="300" height="600"></canvas>
    <div id="overlay" aria-hidden="true"><div class="box" id="message" style="display:none"></div></div>
  </div>

  <div id="panel">
    <div class="panel-card">
      <h1>漂亮的俄罗斯方块</h1>
      <div class="small">触控 / 键盘均支持 · 旋转/Hold/硬降</div>
    </div>

    <div class="panel-card">
      <div class="stat"><div>下一块</div><div id="level">Lv 0</div></div>
      <div class="preview" id="nextPreview"></div>
    </div>

    <div class="panel-card">
      <div class="stat"><div>保留</div><div id="score">分数: 0</div></div>
      <div class="hold" id="holdPreview"></div>
    </div>

    <div class="panel-card">
      <div class="stat"><div>Lines</div><div id="lines">0</div></div>
      <div class="stat"><div>速度</div><div id="speed">正常</div></div>
    </div>

    <div class="panel-card">
      <div class="controls" id="touchControls">
        <div class="btn" id="leftBtn">←</div>
        <div class="btn" id="rightBtn">→</div>
        <div class="btn" id="downBtn">↓</div>
        <div class="btn" id="rotateBtn">R</div>
        <div class="btn" id="hardBtn">Hard</div>
        <div class="btn" id="holdBtn">Hold</div>
      </div>
      <div class="hint" style="margin-top:8px">触控：点击按钮；滑动：左右移动；向下快速滑动可硬降</div>
    </div>

    <div class="panel-card" style="text-align:center;">
      <div class="btn big" id="startBtn">开始 / 重置</div>
      <div class="hint" style="margin-top:8px">键盘：← → ↓ ↑ 空格 (硬降) C(hold) P(暂停)</div>
    </div>
  </div>
</div>

<script>
/* -------------------------
   参数与数据结构
   ------------------------- */
const COLS = 10;
const ROWS = 20;
let cellSize = 30; // will be updated to canvas size
const COLORS = {
  I: '#50C8FF',
  O: '#FFD05B',
  T: '#C778FF',
  S: '#78FF9A',
  Z: '#FF7B8A',
  J: '#6EA7FF',
  L: '#FFB27F',
  GHOST: 'rgba(255,255,255,0.15)'
};
const SHAPES = {
  I: [[1,1,1,1]],
  O: [[1,1],[1,1]],
  T: [[0,1,0],[1,1,1]],
  S: [[0,1,1],[1,1,0]],
  Z: [[1,1,0],[0,1,1]],
  J: [[1,0,0],[1,1,1]],
  L: [[0,0,1],[1,1,1]],
};
const BAG = Object.keys(SHAPES);

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const messageBox = document.getElementById('message');
const overlay = document.getElementById('overlay');

const nextPreview = document.getElementById('nextPreview');
const holdPreview = document.getElementById('holdPreview');
const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
const linesEl = document.getElementById('lines');
const speedEl = document.getElementById('speed');

let grid, current, nextPiece, bag, holdPiece, holdLocked;
let score, linesCleared, level;
let dropInterval = 1000; // ms per cell
let lastDrop = 0;
let gameRunning = false;
let paused = false;

/* -------------------------
   工具函数
   ------------------------- */
function cloneShape(shape){ return shape.map(r => r.slice()); }
function rotate(shape){
  // clockwise rotate
  const H = shape.length, W = shape[0].length;
  const out = Array.from({length:W},()=>Array(H).fill(0));
  for(let r=0;r<H;r++) for(let c=0;c<W;c++) out[c][H-1-r]=shape[r][c];
  return out;
}
function matrixWidth(m){ return m[0].length; }
function matrixHeight(m){ return m.length; }
function randBag(){
  const seq = BAG.slice();
  for(let i=seq.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [seq[i],seq[j]]=[seq[j],seq[i]];
  }
  return seq;
}

/* -------------------------
   游戏逻辑
   ------------------------- */
function resetGame(){
  grid = Array.from({length:ROWS},()=>Array(COLS).fill(null));
  bag = [];
  nextPiece = makePiece(drawFromBag());
  current = makePiece(drawFromBag());
  holdPiece = null;
  holdLocked = false;
  score = 0;
  linesCleared = 0;
  level = 0;
  updateStats();
  dropInterval = 1000;
  gameRunning = true;
  paused = false;
  lastDrop = performance.now();
  hideMessage();
}

function makePiece(kind){
  return {
    kind,
    shape: cloneShape(SHAPES[kind]),
    x: Math.floor(COLS/2) - Math.floor(matrixWidth(SHAPES[kind])/2),
    y: -1
  };
}
function drawFromBag(){
  if(bag.length===0) bag = randBag();
  return bag.shift();
}
function validPosition(piece, dx=0, dy=0){
  const s = piece.shape;
  for(let r=0;r<s.length;r++){
    for(let c=0;c<s[0].length;c++){
      if(!s[r][c]) continue;
      const nx = piece.x + c + dx;
      const ny = piece.y + r + dy;
      if(nx<0 || nx>=COLS || ny>=ROWS) return false;
      if(ny>=0 && grid[ny][nx]) return false;
    }
  }
  return true;
}
function placePiece(piece){
  const s = piece.shape;
  for(let r=0;r<s.length;r++) for(let c=0;c<s[0].length;c++){
    if(!s[r][c]) continue;
    const x = piece.x + c, y = piece.y + r;
    if(y>=0 && y<ROWS && x>=0 && x<COLS) grid[y][x] = piece.kind;
  }
}
function clearLines(){
  let removed = 0;
  for(let r=ROWS-1;r>=0;r--){
    if(grid[r].every(cell=>cell!==null)){
      grid.splice(r,1);
      grid.unshift(Array(COLS).fill(null));
      removed++;
      r++; // re-check same index because rows shift down
    }
  }
  if(removed>0){
    linesCleared += removed;
    score += [0,100,300,500,800][removed] * (level+1);
    level = Math.floor(linesCleared/10);
    dropInterval = Math.max(60, 1000 - level*60);
    updateStats();
  }
}
function gameOverCheck(){
  // if any block in top rows
  return grid[0].some(x=>x!==null);
}
function hardDrop(){
  while(validPosition(current,0,1)){
    current.y++;
  }
  placePiece(current);
  clearLines();
  spawnNext();
}
function spawnNext(){
  current = nextPiece;
  nextPiece = makePiece(drawFromBag());
  holdLocked = false;
  if(!validPosition(current,0,0)){
    gameRunning=false;
    showMessage('游戏结束<br>点击开始重玩');
  }
}

/* -------------------------
   绘制函数
   ------------------------- */
function draw() {
  // scale canvas to CSS size for crisp on various devices
  const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
  if(canvas.width !== Math.floor(cssW * devicePixelRatio) || canvas.height !== Math.floor(cssH * devicePixelRatio)){
    canvas.width = Math.floor(cssW * devicePixelRatio);
    canvas.height = Math.floor(cssH * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    cellSize = cssW / COLS;
  }

  // background gradient on board
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,'rgba(255,255,255,0.02)');
  g.addColorStop(1,'rgba(0,0,0,0.06)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // grid shadow panel
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  ctx.fillRect(0,0,cellSize*COLS,cellSize*ROWS);

  // draw locked blocks
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const k = grid[r][c];
      if(k){
        drawCell(c, r, COLORS[k]);
      } else {
        // grid lines subtle
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        ctx.strokeRect(c*cellSize, r*cellSize, cellSize, cellSize);
      }
    }
  }

  if(current){
    // ghost
    const ghostY = getGhostY();
    for(let r=0;r<current.shape.length;r++){
      for(let c=0;c<current.shape[0].length;c++){
        if(current.shape[r][c]){
          const gx = current.x + c;
          const gy = ghostY + r;
          if(gy>=0) drawCell(gx, gy, COLORS.GHOST, true);
        }
      }
    }
    // current piece
    for(let r=0;r<current.shape.length;r++){
      for(let c=0;c<current.shape[0].length;c++){
        if(current.shape[r][c]){
          const x = current.x + c;
          const y = current.y + r;
          if(y>=0) drawCell(x,y, COLORS[current.kind]);
        }
      }
    }
  }

  // side previews
  renderPreview(nextPreview, nextPiece);
  renderPreview(holdPreview, holdPiece, true);
}

function drawCell(col, row, color, ghost=false){
  const x = col*cellSize, y = row*cellSize;
  const pad = Math.max(1, cellSize*0.06);
  ctx.fillStyle = color;
  if(ghost){
    // translucent
    ctx.fillStyle = color;
  }
  // rounded rect
  const radius = Math.max(2, cellSize*0.12);
  roundRect(ctx, x+pad, y+pad, cellSize-2*pad, cellSize-2*pad, radius, true, false);
  // border highlight
  ctx.strokeStyle = shadeColor(color, -30);
  ctx.lineWidth = Math.max(1, cellSize*0.04);
  roundRect(ctx, x+pad, y+pad, cellSize-2*pad, cellSize-2*pad, radius, false, true);
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if(typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
  ctx.beginPath();
  ctx.moveTo(x + r.tl, y);
  ctx.lineTo(x + w - r.tr, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
  ctx.lineTo(x + w, y + h - r.br);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
  ctx.lineTo(x + r.bl, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
  ctx.lineTo(x, y + r.tl);
  ctx.quadraticCurveTo(x, y, x + r.tl, y);
  ctx.closePath();
  if(fill){ ctx.fill(); }
  if(stroke){ ctx.stroke(); }
}

function renderPreview(container, piece, small=false){
  container.innerHTML = '';
  if(!piece) { container.innerHTML = '<div style="opacity:0.6">—</div>'; return; }
  // draw a small canvas
  const w = 140, h = 100;
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  c.style.width = '100%';
  const ct = c.getContext('2d');
  ct.clearRect(0,0,w,h);
  const s = Math.max(14, Math.min(28, Math.floor(Math.min(w,h)/Math.max(2,matrixWidth(piece.shape)))));
  const offX = Math.floor((w - s*matrixWidth(piece.shape))/2);
  const offY = Math.floor((h - s*matrixHeight(piece.shape))/2);
  for(let r=0;r<piece.shape.length;r++){
    for(let col=0;col<piece.shape[0].length;col++){
      if(piece.shape[r][col]){
        const color = COLORS[piece.kind];
        roundRect(ct, offX + col*s + 1, offY + r*s + 1, s-2, s-2, Math.max(3, s*0.2), true, true);
        ct.fillStyle = color;
        ct.fill();
        ct.strokeStyle = shadeColor(color, -30);
        ct.lineWidth = 2;
        // draw border
        ct.strokeRect(offX + col*s + 1, offY + r*s + 1, s-2, s-2);
      }
    }
  }
  container.appendChild(c);
}

/* -------------------------
   小工具
   ------------------------- */
function shadeColor(col, percent) {
  // col like "#rrggbb" or rgba()
  try{
    if(col.startsWith('rgba')) return col;
    const num = parseInt(col.slice(1),16);
    let r = (num >> 16) + percent;
    let g = ((num >> 8) & 0x00FF) + percent;
    let b = (num & 0x0000FF) + percent;
    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    b = Math.max(0, Math.min(255, b));
    return '#' + (r<<16 | g<<8 | b).toString(16).padStart(6,'0');
  } catch(e){ return col; }
}
function matrixWidth(m){ return m[0].length; }
function matrixHeight(m){ return m.length; }

/* -------------------------
   Ghost y calc
   ------------------------- */
function getGhostY(){
  let y = current.y;
  while(validPosition(current,0,y - current.y + 1)){
    // unreachable - placeholder
    break;
  }
  // simpler: test downward
  let testY = current.y;
  while(validPosition(current,0, testY - current.y + 1)){
    testY++;
    if(!validPosition(current,0,testY - current.y + 1)) break;
    // but above is awkward; better direct:
  }
  // we'll do a loop simpler:
  let ty = current.y;
  while(validPosition(current,0,ty+1-current.y)){
    ty++;
    if(ty>1000) break;
  }
  return ty;
}

/* Actually correct ghost calc that tests by offset */
function getGhostY(){
  let ty = current.y;
  while(true){
    if(!validPosition(current,0,ty - current.y + 1)) break;
    ty++;
  }
  return ty;
}

/* -------------------------
   Main loop
   ------------------------- */
function updateStats(){
  scoreEl.textContent = `分数: ${score}`;
  levelEl.textContent = `Lv ${level}`;
  linesEl.textContent = `${linesCleared}`;
  speedEl.textContent = dropInterval < 400 ? '快' : dropInterval < 800 ? '中' : '慢';
}

/* frame loop */
function tick(now){
  if(!gameRunning || paused){
    draw();
    requestAnimationFrame(tick);
    return;
  }
  const elapsed = now - lastDrop;
  if(elapsed > dropInterval){
    lastDrop = now;
    if(validPosition(current,0,1)){
      current.y++;
    } else {
      placePiece(current);
      clearLines();
      spawnNext();
    }
  }
  draw();
  requestAnimationFrame(tick);
}

/* -------------------------
   Input handling - keyboard & touch
   ------------------------- */
document.addEventListener('keydown', (e)=>{
  if(!gameRunning) return;
  if(e.key === 'ArrowLeft') move(-1);
  if(e.key === 'ArrowRight') move(1);
  if(e.key === 'ArrowDown') { softDrop(true); }
  if(e.key === 'ArrowUp') rotateCurrent();
  if(e.key === ' ') { e.preventDefault(); hardDrop(); }
  if(e.key.toLowerCase() === 'c') hold();
  if(e.key.toLowerCase() === 'p') togglePause();
});
document.addEventListener('keyup', (e)=>{
  if(e.key === 'ArrowDown') softDrop(false);
});

function move(dir){
  if(validPosition(current,dir,0)) current.x += dir;
}
function rotateCurrent(){
  const old = cloneShape(current.shape);
  current.shape = rotate(current.shape);
  // simple wall kick try
  if(!validPosition(current,0,0)){
    if(validPosition(current,-1,0)) current.x -=1;
    else if(validPosition(current,1,0)) current.x +=1;
    else current.shape = old;
  }
}
let soft = false;
function softDrop(on){
  soft = on;
  if(soft) dropInterval = 60;
  else dropInterval = Math.max(60, 1000 - level*60);
}
function hold(){
  if(holdLocked) return;
  if(!holdPiece){
    holdPiece = makePiece(current.kind);
    current = nextPiece;
    nextPiece = makePiece(drawFromBag());
  } else {
    const tmp = makePiece(holdPiece.kind);
    // swap shapes/kind properly
    holdPiece = makePiece(current.kind);
    current = tmp;
  }
  holdLocked = true;
  updateStats();
}

const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const downBtn = document.getElementById('downBtn');
const rotateBtn = document.getElementById('rotateBtn');
const hardBtn = document.getElementById('hardBtn');
const holdBtn = document.getElementById('holdBtn');

leftBtn.addEventListener('touchstart', ()=>move(-1));
rightBtn.addEventListener('touchstart', ()=>move(1));
downBtn.addEventListener('touchstart', ()=>{ softDrop(true); });
downBtn.addEventListener('touchend', ()=>{ softDrop(false); });
rotateBtn.addEventListener('touchstart', ()=>rotateCurrent());
hardBtn.addEventListener('touchstart', ()=>{ hardDrop(); });
holdBtn.addEventListener('touchstart', ()=>hold());

/* add click support for desktop */
leftBtn.addEventListener('mousedown', ()=>move(-1));
rightBtn.addEventListener('mousedown', ()=>move(1));
downBtn.addEventListener('mousedown', ()=>{ softDrop(true); });
downBtn.addEventListener('mouseup', ()=>{ softDrop(false); });
rotateBtn.addEventListener('mousedown', ()=>rotateCurrent());
hardBtn.addEventListener('mousedown', ()=>{ hardDrop(); });
holdBtn.addEventListener('mousedown', ()=>hold());

/* swipe gestures on main board */
let touchStartX=null, touchStartY=null, touchStartT=0;
canvas.addEventListener('touchstart',(e)=>{
  if(!gameRunning) return;
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
  touchStartT = performance.now();
}, {passive:true});

canvas.addEventListener('touchend',(e)=>{
  if(!gameRunning) return;
  const touch = e.changedTouches[0];
  const dx = touch.clientX - touchStartX;
  const dy = touch.clientY - touchStartY;
  const dt = performance.now() - touchStartT;
  if(Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 20){
    // horizontal swipe
    if(dx < 0) move(-1);
    else move(1);
  } else if(Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 20){
    // vertical swipe
    if(dy > 0 && dt < 350){
      // fast downward swipe -> hard drop
      hardDrop();
    } else if(dy > 0){
      // soft drop hold
      softDrop(true);
      setTimeout(()=>softDrop(false), 300);
    } else {
      // upward swipe -> rotate
      rotateCurrent();
    }
  } else {
    // tap -> rotate
    rotateCurrent();
  }
}, {passive:true});

/* -------------------------
   HUD / message
   ------------------------- */
function showMessage(html){
  messageBox.innerHTML = html;
  messageBox.style.display = 'block';
  overlay.style.pointerEvents = 'auto';
}
function hideMessage(){
  messageBox.style.display = 'none';
  overlay.style.pointerEvents = 'none';
}

/* -------------------------
   Start & helpers
   ------------------------- */
startBtn.addEventListener('click', ()=>{
  resetGame();
});

function spawnInitial(){
  bag = randBag();
  nextPiece = makePiece(drawFromBag());
  current = makePiece(drawFromBag());
  updateStats();
}

/* auto start one */
spawnInitial();
resetGame();
requestAnimationFrame(tick);

/* utility: expose some debug commands */
window.tetris = {
  reset: resetGame,
  grid,
  current
};
</script>
</body>
</html>